package model

// Code generated by go-bridget/mig. DO NOT EDIT.

import (
	"fmt"
	"strings"
	"time"
)

type QueryOption interface {
	WithTable(name string) QueryOption
	WithColumns(cols []string) QueryOption
	WithWhere(clause string) QueryOption
	WithOrderBy(clause string) QueryOption
	WithLimit(start, offset int) QueryOption
	WithStatement(stmt string) QueryOption
}

type QueryConfig struct {
	Table       string
	Columns     []string
	Where       string
	OrderBy     string
	LimitStart  int
	LimitOffset int
	Statement   string
}

func (q *QueryConfig) WithTable(name string) QueryOption {
	q.Table = name
	return q
}

func (q *QueryConfig) WithColumns(cols []string) QueryOption {
	q.Columns = cols
	return q
}

func (q *QueryConfig) WithWhere(clause string) QueryOption {
	q.Where = clause
	return q
}

func (q *QueryConfig) WithOrderBy(clause string) QueryOption {
	q.OrderBy = clause
	return q
}

func (q *QueryConfig) WithLimit(start, offset int) QueryOption {
	q.LimitStart = start
	q.LimitOffset = offset
	return q
}

func (q *QueryConfig) WithStatement(stmt string) QueryOption {
	q.Statement = stmt
	return q
}

func WithTable(name string) QueryOption {
	return &QueryConfig{Table: name}
}

func WithColumns(cols []string) QueryOption {
	return &QueryConfig{Columns: cols}
}

func WithWhere(clause string) QueryOption {
	return &QueryConfig{Where: clause}
}

func WithOrderBy(clause string) QueryOption {
	return &QueryConfig{OrderBy: clause}
}

func WithLimit(start, offset int) QueryOption {
	return &QueryConfig{LimitStart: start, LimitOffset: offset}
}

func WithStatement(stmt string) QueryOption {
	return &QueryConfig{Statement: stmt}
}

func (q *QueryConfig) Apply(opts ...QueryOption) *QueryConfig {
	cfg := *q
	for _, opt := range opts {
		o := opt.(*QueryConfig)
		if o.Table != "" {
			cfg.Table = o.Table
		}
		if len(o.Columns) > 0 {
			cfg.Columns = o.Columns
		}
		if o.Where != "" {
			cfg.Where = o.Where
		}
		if o.OrderBy != "" {
			cfg.OrderBy = o.OrderBy
		}
		if o.LimitOffset > 0 {
			cfg.LimitStart = o.LimitStart
			cfg.LimitOffset = o.LimitOffset
		}
		if o.Statement != "" {
			cfg.Statement = o.Statement
		}
	}
	return &cfg
}

// Migrations generated for db table `migrations`.
type Migrations struct {
	// Project
	Project string `db:"project"`

	// Filename
	Filename string `db:"filename"`

	// Statement Index
	StatementIndex int64 `db:"statement_index"`

	// Status
	Status string `db:"status"`
}

// GetProject will return the value of Project.
func (m *Migrations) GetProject() string { return m.Project }

// GetFilename will return the value of Filename.
func (m *Migrations) GetFilename() string { return m.Filename }

// GetStatementIndex will return the value of StatementIndex.
func (m *Migrations) GetStatementIndex() int64 { return m.StatementIndex }

// GetStatus will return the value of Status.
func (m *Migrations) GetStatus() string { return m.Status }

// MigrationsTable is the name of the table in the DB.
const MigrationsTable = "`migrations`"

// MigrationsFields is a list of all columns in the DB table.
var MigrationsFields = []string{"project", "filename", "statement_index", "status"}

// MigrationsPrimaryFields are the primary key fields in the DB table.
var MigrationsPrimaryFields = []string{"project"}

// Email generated for db table `email`.
type Email struct {
	// ID
	ID string `db:"id"`

	// Recipient
	Recipient string `db:"recipient"`

	// Subject
	Subject string `db:"subject"`

	// Body
	Body string `db:"body"`

	// Status
	Status string `db:"status"`

	// Error
	Error string `db:"error"`

	// Created At
	CreatedAt *time.Time `db:"created_at"`

	// Sent At
	SentAt *time.Time `db:"sent_at"`

	// Retry Count
	RetryCount int64 `db:"retry_count"`

	// Retry Error
	RetryError string `db:"retry_error"`

	// Retry At
	RetryAt *time.Time `db:"retry_at"`
}

// GetID will return the value of ID.
func (e *Email) GetID() string { return e.ID }

// GetRecipient will return the value of Recipient.
func (e *Email) GetRecipient() string { return e.Recipient }

// GetSubject will return the value of Subject.
func (e *Email) GetSubject() string { return e.Subject }

// GetBody will return the value of Body.
func (e *Email) GetBody() string { return e.Body }

// GetStatus will return the value of Status.
func (e *Email) GetStatus() string { return e.Status }

// GetError will return the value of Error.
func (e *Email) GetError() string { return e.Error }

// GetCreatedAt will return the value of CreatedAt.
func (e *Email) GetCreatedAt() *time.Time { return e.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (e *Email) SetCreatedAt(stamp time.Time) { e.CreatedAt = &stamp }

// GetSentAt will return the value of SentAt.
func (e *Email) GetSentAt() *time.Time { return e.SentAt }

// SetSentAt sets SentAt to the provided value.
func (e *Email) SetSentAt(stamp time.Time) { e.SentAt = &stamp }

// GetRetryCount will return the value of RetryCount.
func (e *Email) GetRetryCount() int64 { return e.RetryCount }

// GetRetryError will return the value of RetryError.
func (e *Email) GetRetryError() string { return e.RetryError }

// GetRetryAt will return the value of RetryAt.
func (e *Email) GetRetryAt() *time.Time { return e.RetryAt }

// SetRetryAt sets RetryAt to the provided value.
func (e *Email) SetRetryAt(stamp time.Time) { e.RetryAt = &stamp }

// EmailTable is the name of the table in the DB.
const EmailTable = "`email`"

// EmailFields is a list of all columns in the DB table.
var EmailFields = []string{"id", "recipient", "subject", "body", "status", "error", "created_at", "sent_at", "retry_count", "retry_error", "retry_at"}

// EmailPrimaryFields are the primary key fields in the DB table.
var EmailPrimaryFields = []string{"id"}

// EmailSent generated for db table `email_sent`.
type EmailSent struct {
	// ID
	ID string `db:"id"`

	// Recipient
	Recipient string `db:"recipient"`

	// Subject
	Subject string `db:"subject"`

	// Body
	Body string `db:"body"`

	// Status
	Status string `db:"status"`

	// Error
	Error string `db:"error"`

	// Created At
	CreatedAt *time.Time `db:"created_at"`

	// Sent At
	SentAt *time.Time `db:"sent_at"`

	// Retry Count
	RetryCount int64 `db:"retry_count"`

	// Retry Error
	RetryError string `db:"retry_error"`

	// Retry At
	RetryAt *time.Time `db:"retry_at"`
}

// GetID will return the value of ID.
func (e *EmailSent) GetID() string { return e.ID }

// GetRecipient will return the value of Recipient.
func (e *EmailSent) GetRecipient() string { return e.Recipient }

// GetSubject will return the value of Subject.
func (e *EmailSent) GetSubject() string { return e.Subject }

// GetBody will return the value of Body.
func (e *EmailSent) GetBody() string { return e.Body }

// GetStatus will return the value of Status.
func (e *EmailSent) GetStatus() string { return e.Status }

// GetError will return the value of Error.
func (e *EmailSent) GetError() string { return e.Error }

// GetCreatedAt will return the value of CreatedAt.
func (e *EmailSent) GetCreatedAt() *time.Time { return e.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (e *EmailSent) SetCreatedAt(stamp time.Time) { e.CreatedAt = &stamp }

// GetSentAt will return the value of SentAt.
func (e *EmailSent) GetSentAt() *time.Time { return e.SentAt }

// SetSentAt sets SentAt to the provided value.
func (e *EmailSent) SetSentAt(stamp time.Time) { e.SentAt = &stamp }

// GetRetryCount will return the value of RetryCount.
func (e *EmailSent) GetRetryCount() int64 { return e.RetryCount }

// GetRetryError will return the value of RetryError.
func (e *EmailSent) GetRetryError() string { return e.RetryError }

// GetRetryAt will return the value of RetryAt.
func (e *EmailSent) GetRetryAt() *time.Time { return e.RetryAt }

// SetRetryAt sets RetryAt to the provided value.
func (e *EmailSent) SetRetryAt(stamp time.Time) { e.RetryAt = &stamp }

// EmailSentTable is the name of the table in the DB.
const EmailSentTable = "`email_sent`"

// EmailSentFields is a list of all columns in the DB table.
var EmailSentFields = []string{"id", "recipient", "subject", "body", "status", "error", "created_at", "sent_at", "retry_count", "retry_error", "retry_at"}

// EmailSentPrimaryFields are the primary key fields in the DB table.
var EmailSentPrimaryFields = []string{"id"}

// EmailFailed generated for db table `email_failed`.
type EmailFailed struct {
	// ID
	ID string `db:"id"`

	// Recipient
	Recipient string `db:"recipient"`

	// Subject
	Subject string `db:"subject"`

	// Body
	Body string `db:"body"`

	// Status
	Status string `db:"status"`

	// Error
	Error string `db:"error"`

	// Created At
	CreatedAt *time.Time `db:"created_at"`

	// Sent At
	SentAt *time.Time `db:"sent_at"`

	// Retry Count
	RetryCount int64 `db:"retry_count"`

	// Retry Error
	RetryError string `db:"retry_error"`

	// Retry At
	RetryAt *time.Time `db:"retry_at"`
}

// GetID will return the value of ID.
func (e *EmailFailed) GetID() string { return e.ID }

// GetRecipient will return the value of Recipient.
func (e *EmailFailed) GetRecipient() string { return e.Recipient }

// GetSubject will return the value of Subject.
func (e *EmailFailed) GetSubject() string { return e.Subject }

// GetBody will return the value of Body.
func (e *EmailFailed) GetBody() string { return e.Body }

// GetStatus will return the value of Status.
func (e *EmailFailed) GetStatus() string { return e.Status }

// GetError will return the value of Error.
func (e *EmailFailed) GetError() string { return e.Error }

// GetCreatedAt will return the value of CreatedAt.
func (e *EmailFailed) GetCreatedAt() *time.Time { return e.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (e *EmailFailed) SetCreatedAt(stamp time.Time) { e.CreatedAt = &stamp }

// GetSentAt will return the value of SentAt.
func (e *EmailFailed) GetSentAt() *time.Time { return e.SentAt }

// SetSentAt sets SentAt to the provided value.
func (e *EmailFailed) SetSentAt(stamp time.Time) { e.SentAt = &stamp }

// GetRetryCount will return the value of RetryCount.
func (e *EmailFailed) GetRetryCount() int64 { return e.RetryCount }

// GetRetryError will return the value of RetryError.
func (e *EmailFailed) GetRetryError() string { return e.RetryError }

// GetRetryAt will return the value of RetryAt.
func (e *EmailFailed) GetRetryAt() *time.Time { return e.RetryAt }

// SetRetryAt sets RetryAt to the provided value.
func (e *EmailFailed) SetRetryAt(stamp time.Time) { e.RetryAt = &stamp }

// EmailFailedTable is the name of the table in the DB.
const EmailFailedTable = "`email_failed`"

// EmailFailedFields is a list of all columns in the DB table.
var EmailFailedFields = []string{"id", "recipient", "subject", "body", "status", "error", "created_at", "sent_at", "retry_count", "retry_error", "retry_at"}

// EmailFailedPrimaryFields are the primary key fields in the DB table.
var EmailFailedPrimaryFields = []string{"id"}

func (m *Migrations) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := MigrationsFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

func (m *Migrations) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

func (m *Migrations) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	cols := MigrationsFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (m *Migrations) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *Email) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := EmailFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

func (e *Email) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

func (e *Email) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailTable}).Apply(opts...)
	cols := EmailFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *Email) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *EmailSent) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailSentTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := EmailSentFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

func (e *EmailSent) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailSentTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

func (e *EmailSent) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailSentTable}).Apply(opts...)
	cols := EmailSentFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *EmailSent) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailSentTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *EmailFailed) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailFailedTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := EmailFailedFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

func (e *EmailFailed) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailFailedTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

func (e *EmailFailed) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailFailedTable}).Apply(opts...)
	cols := EmailFailedFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *EmailFailed) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EmailFailedTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}
