package model

// Code generated by go-bridget/mig. DO NOT EDIT.

import (
	"fmt"
	"strings"
	"time"
)

// QueryOption is implemented by each data model type.
type QueryOption interface {
	WithTable(name string) QueryOption
	WithColumns(cols []string) QueryOption
	WithWhere(clause string) QueryOption
	WithOrderBy(clause string) QueryOption
	WithLimit(start, offset int) QueryOption
	WithStatement(stmt string) QueryOption
}

// QueryConfig is a function-chaining SQL statement type.
type QueryConfig struct {
	Table       string
	Columns     []string
	Where       string
	OrderBy     string
	LimitStart  int
	LimitOffset int
	Statement   string
}

// WithTable will set the table name for the query.
func (q *QueryConfig) WithTable(name string) QueryOption {
	q.Table = name
	return q
}

// WithColumns will set the columns to use for the query.
func (q *QueryConfig) WithColumns(cols []string) QueryOption {
	q.Columns = cols
	return q
}

// WithWhere will set the where condition for the query.
func (q *QueryConfig) WithWhere(clause string) QueryOption {
	q.Where = clause
	return q
}

// WithOrderBy will set the order by clause for the query.
func (q *QueryConfig) WithOrderBy(clause string) QueryOption {
	q.OrderBy = clause
	return q
}

// WithLimit will set the limit clause parameters for the query.
func (q *QueryConfig) WithLimit(start, offset int) QueryOption {
	q.LimitStart = start
	q.LimitOffset = offset
	return q
}

// WithStatement will change the statement for the query.
func (q *QueryConfig) WithStatement(stmt string) QueryOption {
	q.Statement = stmt
	return q
}

// WithTable will set the table name for the query.
func WithTable(name string) QueryOption {
	return &QueryConfig{Table: name}
}

// WithColumns will set the columns to use for the query.
func WithColumns(cols []string) QueryOption {
	return &QueryConfig{Columns: cols}
}

// WithWhere will set the where condition for the query.
func WithWhere(clause string) QueryOption {
	return &QueryConfig{Where: clause}
}

// WithOrderBy will set the order by clause for the query.
func WithOrderBy(clause string) QueryOption {
	return &QueryConfig{OrderBy: clause}
}

// WithLimit will set the limit clause parameters for the query.
func WithLimit(start, offset int) QueryOption {
	return &QueryConfig{LimitStart: start, LimitOffset: offset}
}

// WithStatement will change the statement for the query.
func WithStatement(stmt string) QueryOption {
	return &QueryConfig{Statement: stmt}
}

// Apply will use passed query options to populate the query.
func (q *QueryConfig) Apply(opts ...QueryOption) *QueryConfig {
	cfg := *q
	for _, opt := range opts {
		o := opt.(*QueryConfig)
		if o.Table != "" {
			cfg.Table = o.Table
		}
		if len(o.Columns) > 0 {
			cfg.Columns = o.Columns
		}
		if o.Where != "" {
			cfg.Where = o.Where
		}
		if o.OrderBy != "" {
			cfg.OrderBy = o.OrderBy
		}
		if o.LimitOffset > 0 {
			cfg.LimitStart = o.LimitStart
			cfg.LimitOffset = o.LimitOffset
		}
		if o.Statement != "" {
			cfg.Statement = o.Statement
		}
	}
	return &cfg
}

// Migrations generated for db table `migrations`.
//
// Migrations.
type Migrations struct {
	// Project
	Project string `db:"project"`

	// Filename
	Filename string `db:"filename"`

	// Statement Index
	StatementIndex int64 `db:"statement_index"`

	// Status
	Status string `db:"status"`
}

// GetProject will return the value of Project.
func (m *Migrations) GetProject() string { return m.Project }

// GetFilename will return the value of Filename.
func (m *Migrations) GetFilename() string { return m.Filename }

// GetStatementIndex will return the value of StatementIndex.
func (m *Migrations) GetStatementIndex() int64 { return m.StatementIndex }

// GetStatus will return the value of Status.
func (m *Migrations) GetStatus() string { return m.Status }

// MigrationsTable is the name of the table in the DB.
const MigrationsTable = "`migrations`"

// MigrationsFields is a list of all columns in the DB table.
var MigrationsFields = []string{"project", "filename", "statement_index", "status"}

// MigrationsPrimaryFields are the primary key fields in the DB table.
var MigrationsPrimaryFields = []string{"project", "filename"}

// User generated for db table `user`.
//
// User.
type User struct {
	// ID
	ID string `db:"id"`

	// First Name
	FirstName string `db:"first_name"`

	// Last Name
	LastName string `db:"last_name"`

	// Username
	Username string `db:"username"`

	// Slug
	Slug string `db:"slug"`

	// Deleted At
	DeletedAt *time.Time `db:"deleted_at"`

	// Created At
	CreatedAt *time.Time `db:"created_at"`

	// Updated At
	UpdatedAt *time.Time `db:"updated_at"`
}

// GetID will return the value of ID.
func (u *User) GetID() string { return u.ID }

// GetFirstName will return the value of FirstName.
func (u *User) GetFirstName() string { return u.FirstName }

// GetLastName will return the value of LastName.
func (u *User) GetLastName() string { return u.LastName }

// GetUsername will return the value of Username.
func (u *User) GetUsername() string { return u.Username }

// GetSlug will return the value of Slug.
func (u *User) GetSlug() string { return u.Slug }

// GetDeletedAt will return the value of DeletedAt.
func (u *User) GetDeletedAt() *time.Time { return u.DeletedAt }

// SetDeletedAt sets DeletedAt to the provided value.
func (u *User) SetDeletedAt(stamp time.Time) { u.DeletedAt = &stamp }

// GetCreatedAt will return the value of CreatedAt.
func (u *User) GetCreatedAt() *time.Time { return u.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (u *User) SetCreatedAt(stamp time.Time) { u.CreatedAt = &stamp }

// GetUpdatedAt will return the value of UpdatedAt.
func (u *User) GetUpdatedAt() *time.Time { return u.UpdatedAt }

// SetUpdatedAt sets UpdatedAt to the provided value.
func (u *User) SetUpdatedAt(stamp time.Time) { u.UpdatedAt = &stamp }

// UserTable is the name of the table in the DB.
const UserTable = "`user`"

// UserFields is a list of all columns in the DB table.
var UserFields = []string{"id", "first_name", "last_name", "username", "slug", "deleted_at", "created_at", "updated_at"}

// UserPrimaryFields are the primary key fields in the DB table.
var UserPrimaryFields = []string{"id"}

// UserAuth generated for db table `user_auth`.
//
// User Auth.
type UserAuth struct {
	// User ID
	UserID string `db:"user_id"`

	// Email
	Email string `db:"email"`

	// Password
	Password string `db:"password"`

	// Created At
	CreatedAt *time.Time `db:"created_at"`

	// Updated At
	UpdatedAt *time.Time `db:"updated_at"`
}

// GetUserID will return the value of UserID.
func (u *UserAuth) GetUserID() string { return u.UserID }

// GetEmail will return the value of Email.
func (u *UserAuth) GetEmail() string { return u.Email }

// GetPassword will return the value of Password.
func (u *UserAuth) GetPassword() string { return u.Password }

// GetCreatedAt will return the value of CreatedAt.
func (u *UserAuth) GetCreatedAt() *time.Time { return u.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (u *UserAuth) SetCreatedAt(stamp time.Time) { u.CreatedAt = &stamp }

// GetUpdatedAt will return the value of UpdatedAt.
func (u *UserAuth) GetUpdatedAt() *time.Time { return u.UpdatedAt }

// SetUpdatedAt sets UpdatedAt to the provided value.
func (u *UserAuth) SetUpdatedAt(stamp time.Time) { u.UpdatedAt = &stamp }

// UserAuthTable is the name of the table in the DB.
const UserAuthTable = "`user_auth`"

// UserAuthFields is a list of all columns in the DB table.
var UserAuthFields = []string{"user_id", "email", "password", "created_at", "updated_at"}

// UserAuthPrimaryFields are the primary key fields in the DB table.
var UserAuthPrimaryFields = []string{"user_id"}

// UserGroup generated for db table `user_group`.
//
// User Group.
type UserGroup struct {
	// ID
	ID string `db:"id"`

	// Title
	Title string `db:"title"`

	// Created At
	CreatedAt *time.Time `db:"created_at"`

	// Updated At
	UpdatedAt *time.Time `db:"updated_at"`
}

// GetID will return the value of ID.
func (u *UserGroup) GetID() string { return u.ID }

// GetTitle will return the value of Title.
func (u *UserGroup) GetTitle() string { return u.Title }

// GetCreatedAt will return the value of CreatedAt.
func (u *UserGroup) GetCreatedAt() *time.Time { return u.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (u *UserGroup) SetCreatedAt(stamp time.Time) { u.CreatedAt = &stamp }

// GetUpdatedAt will return the value of UpdatedAt.
func (u *UserGroup) GetUpdatedAt() *time.Time { return u.UpdatedAt }

// SetUpdatedAt sets UpdatedAt to the provided value.
func (u *UserGroup) SetUpdatedAt(stamp time.Time) { u.UpdatedAt = &stamp }

// UserGroupTable is the name of the table in the DB.
const UserGroupTable = "`user_group`"

// UserGroupFields is a list of all columns in the DB table.
var UserGroupFields = []string{"id", "title", "created_at", "updated_at"}

// UserGroupPrimaryFields are the primary key fields in the DB table.
var UserGroupPrimaryFields = []string{"id"}

// UserGroupMember generated for db table `user_group_member`.
//
// User Group Member.
type UserGroupMember struct {
	// User Group ID
	UserGroupID string `db:"user_group_id"`

	// User ID
	UserID string `db:"user_id"`

	// Joined At
	JoinedAt *time.Time `db:"joined_at"`
}

// GetUserGroupID will return the value of UserGroupID.
func (u *UserGroupMember) GetUserGroupID() string { return u.UserGroupID }

// GetUserID will return the value of UserID.
func (u *UserGroupMember) GetUserID() string { return u.UserID }

// GetJoinedAt will return the value of JoinedAt.
func (u *UserGroupMember) GetJoinedAt() *time.Time { return u.JoinedAt }

// SetJoinedAt sets JoinedAt to the provided value.
func (u *UserGroupMember) SetJoinedAt(stamp time.Time) { u.JoinedAt = &stamp }

// UserGroupMemberTable is the name of the table in the DB.
const UserGroupMemberTable = "`user_group_member`"

// UserGroupMemberFields is a list of all columns in the DB table.
var UserGroupMemberFields = []string{"user_group_id", "user_id", "joined_at"}

// UserGroupMemberPrimaryFields are the primary key fields in the DB table.
var UserGroupMemberPrimaryFields = []string{"user_group_id", "user_id"}

// UserSession generated for db table `user_session`.
//
// User Session.
type UserSession struct {
	// ID
	ID string `db:"id"`

	// User ID
	UserID string `db:"user_id"`

	// Expires At
	ExpiresAt *time.Time `db:"expires_at"`

	// Created At
	CreatedAt *time.Time `db:"created_at"`
}

// GetID will return the value of ID.
func (u *UserSession) GetID() string { return u.ID }

// GetUserID will return the value of UserID.
func (u *UserSession) GetUserID() string { return u.UserID }

// GetExpiresAt will return the value of ExpiresAt.
func (u *UserSession) GetExpiresAt() *time.Time { return u.ExpiresAt }

// SetExpiresAt sets ExpiresAt to the provided value.
func (u *UserSession) SetExpiresAt(stamp time.Time) { u.ExpiresAt = &stamp }

// GetCreatedAt will return the value of CreatedAt.
func (u *UserSession) GetCreatedAt() *time.Time { return u.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (u *UserSession) SetCreatedAt(stamp time.Time) { u.CreatedAt = &stamp }

// UserSessionTable is the name of the table in the DB.
const UserSessionTable = "`user_session`"

// UserSessionFields is a list of all columns in the DB table.
var UserSessionFields = []string{"id", "user_id", "expires_at", "created_at"}

// UserSessionPrimaryFields are the primary key fields in the DB table.
var UserSessionPrimaryFields = []string{"id"}

// Insert starts building an INSERT INTO query.
func (m *Migrations) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := MigrationsFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

// Select starts building a SELECT query.
func (m *Migrations) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

// Update starts building a UPDATE query.
func (m *Migrations) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	cols := MigrationsFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Delete starts building a DELETE query.
func (m *Migrations) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Insert starts building an INSERT INTO query.
func (u *User) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := UserFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

// Select starts building a SELECT query.
func (u *User) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

// Update starts building a UPDATE query.
func (u *User) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserTable}).Apply(opts...)
	cols := UserFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Delete starts building a DELETE query.
func (u *User) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Insert starts building an INSERT INTO query.
func (u *UserAuth) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserAuthTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := UserAuthFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

// Select starts building a SELECT query.
func (u *UserAuth) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserAuthTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

// Update starts building a UPDATE query.
func (u *UserAuth) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserAuthTable}).Apply(opts...)
	cols := UserAuthFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Delete starts building a DELETE query.
func (u *UserAuth) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserAuthTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Insert starts building an INSERT INTO query.
func (u *UserGroup) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := UserGroupFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

// Select starts building a SELECT query.
func (u *UserGroup) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

// Update starts building a UPDATE query.
func (u *UserGroup) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupTable}).Apply(opts...)
	cols := UserGroupFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Delete starts building a DELETE query.
func (u *UserGroup) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Insert starts building an INSERT INTO query.
func (u *UserGroupMember) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupMemberTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := UserGroupMemberFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

// Select starts building a SELECT query.
func (u *UserGroupMember) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupMemberTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

// Update starts building a UPDATE query.
func (u *UserGroupMember) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupMemberTable}).Apply(opts...)
	cols := UserGroupMemberFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Delete starts building a DELETE query.
func (u *UserGroupMember) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserGroupMemberTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Insert starts building an INSERT INTO query.
func (u *UserSession) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserSessionTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := UserSessionFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

// Select starts building a SELECT query.
func (u *UserSession) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserSessionTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

// Update starts building a UPDATE query.
func (u *UserSession) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserSessionTable}).Apply(opts...)
	cols := UserSessionFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

// Delete starts building a DELETE query.
func (u *UserSession) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: UserSessionTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}
